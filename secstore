#!/usr/bin/perl

# Copyright (c) 2023-2025 Alex Arch <aa@manpager.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use File::Basename;
use File::Path 'make_path';
use Getopt::Std;
use IPC::Open2;
use POSIX qw(setsid);
use Text::ParseWords;

use Digest::SHA 'sha256';

our $opt_d;

# usage: print usage information to stderr and exit with error.
sub usage {
	die "usage: secstore [-d dir] command [arg ...]\n";
}

# getflags: put environment flags at the start of @ARGV
sub getflags {
	my ($var) = @_;
	unshift(@ARGV, shellwords $ENV{$var} // '') if defined $var && $var ne '';
}

# shellquote: return string suitable for using as an argument for sh
sub shellquote {
	my ($s) = @_;
	$s =~ s/'/'\\''/g;
	return "'" . $s . "'";
}

# ckpath $path
#
# Return 1 if $path is not empty, doesn't start with /, or contain .. or .,
# and 0 otherwise.
sub ckpath {
	my ($p) = @_;
	return $p ne '' && $p !~ m,^/, && $p !~ m/\.\.?/ && $p !~ m,^\.\.?/, &&
	    $p !~ m,/\.\.?/, && $p !~ m,/\.\.?$,;
}

# prunetree $d: remove empty directories, starting from $d, and going up.
sub prunetree {
	for (my ($d) = @_; $d ne "."; $d = dirname $d) {
		rmdir $d or last;
	}
}

# secstore_add
#
# Encrypt the secret from stdin, and store the ciphertext in file specified
# on the command line.
sub secstore_add {
	our ($opt_N, $opt_n);
	my ($cmd, $sec) = ($ENV{SECSTORE_ENCCMD} // 'gpg -e --', '');

	local *usage = sub {
		die "usage: secstore add [-Nn] name\n";
	};

	getopts('Nn') && scalar(@ARGV) == 1 or usage();

	my $outfile = $ARGV[0];
	ckpath $outfile or die "bad path: $outfile\n";

	-e $outfile and die "$outfile already exists\n";

	if (-t STDIN) {
		open TTY, "/dev/tty" || die "couldn't open /dev/tty: $!\n";
		system "stty -echo";

		print "Secret:";
		$sec = <TTY>;
		print "\n";
		print "Repeat:";
		my $sec2 = <TTY>;
		print "\n";
		if ($opt_n && !$opt_N) {
			chomp $sec;
			chomp $sec2;
		}

		system "stty echo";
		close TTY;
		die "Sorry\n" if $sec ne $sec2;
		undef $sec2;
	} else {
		while (<STDIN>) { $sec .= $_; }
	}

	my $pid = open2(my $reader, my $writer, $cmd);
	print $writer $sec;
	undef $sec;
	close $writer;
	my $out = '';
	while (<$reader>) { $out .= $_; }
	waitpid $pid, 0;
	$? == 0 or exit 1;

	my $d = dirname $outfile;
	make_path $d, {mode => 0700};
	umask 0377;
	unless (open(FH, ">$outfile") && print(FH $out)) {
		prunetree $d;
		die "couldn't write to $outfile: $!\n";
	}
}

# secstore_list
#
# Produce a listing of files in the gpm directory, using the SECSTORE_LSCMD
# environment variable if defined.
sub secstore_list {
	my $cmd = $ENV{SECSTORE_LSCMD};

	unless (defined $cmd) {
		opendir my $dh, "." or die "couldn't open directory .: $!\n";
		while (readdir $dh) {
			if ($_ ne "." && $_ ne ".." && -d $_) {
				$cmd = "find . -type f | sed 's,^\./,,'";
				last;
			}
		}
		$cmd = "ls" unless defined $cmd;
	}
	system $cmd;
	$? == 0 or exit 1;
}

# secstore_move: safely rename $ARGV[0] to $ARGV[1].
sub secstore_move {
	local *usage = sub {
		die "usage: secstore move from to\n";
	};
	scalar(@ARGV) == 2 || usage();
	my ($from, $to) = @ARGV;

	ckpath $from or die "bad path $from\n";
	ckpath $to or die "bad path $to\n";
	-e $to and die "$to already existst\n";

	make_path(dirname $to, {mode => 0700});
	rename $from, $to;
	prunetree(dirname $from);
}

# secstore_remove: unlink arguments, asking each time.
sub secstore_remove {
	local *usage = sub {
		die "usage: secstore remove name [name ...]\n";
	};
	scalar(@ARGV) >= 1 || usage();
	for (@ARGV) {
		my $f = $_;
		unless (ckpath $f) {
			print STDERR "bad path $f\n";
			next;
		}
		print "Really remove $f? ";
		<STDIN> =~ m/^[Yy]/ and unlink $f;
		prunetree(dirname $f);
	}
}

# get: decrypt file, and return plaintext.
sub get {
	my ($Nflag, $nflag, $file) = @_;
	my $cmd = $ENV{SECSTORE_DECCMD} // "gpg -dq --";

	ckpath $file or die "bad path: $file\n";
	-f $file or die "no such file: $file\n";

	open(my $freader, "<$file") or die "Couldn't open <$file: $!\n";
	my $pid = open2(my $cmdreader, my $cmdwriter, $cmd);
	print $cmdwriter $_ while (<$freader>); 
	close $cmdwriter;
	close $freader;
	my $out = '';
	while (<$cmdreader>) { $out .= $_; }
	waitpid $pid, 0;
	$? == 0 or exit 1;
	chomp($out) if ($nflag && !$Nflag);

	return $out;
}

# secstore_print: decrypt file, and print plaintext to stdout.
sub secstore_print {
	our ($opt_N, $opt_n);
	local *usage = sub {
		die "usage: secstore print [-Nn] name ...";
	};
	getopts('Nn') && scalar(@ARGV) == 1 or usage();
	print(get $opt_N, $opt_n, $ARGV[0]);
}

# copy: decrypt file, and copy to SECSTORE_COPY_INCMD, delete with
# SECSTORE_COPY_DELCMD after SECSTORE_COPY_SLEEP seconds if necessary.
sub secstore_copy {
	our ($opt_N, $opt_n, $opt_d, $opt_i, $opt_o, $opt_s);
	local *usage = sub {
		die
"usage: secstore copy [-Nn] [-d delcmd] [-i incmd] [-o outcmd] [-s sleeptime]\n" .
"                     name\n"
	};

	getopts('Nnd:i:o:s:') && scalar(@ARGV) == 1 or usage();

	my $delcmd =	$opt_d // $ENV{SECSTORE_COPY_DELCMD} // "xclip </dev/null";
	my $incmd =	$opt_i // $ENV{SECSTORE_COPY_INCMD} // "xclip";
	my $outcmd =	$opt_o // $ENV{SECSTORE_COPY_OUTCMD} // "xclip -o";
	my $sleep =	$opt_s // $ENV{SECSTORE_COPY_SLEEP} // 60;

	my $pw = get $opt_N, $opt_n, $ARGV[0];

	# This is a huge cludge. The reason we have to do copying inside a detached
	# process is because otherwise the following doesn't work (assuming xclip):
	#
	# $ tmux popup -E 'GPG_TTY=`tty` isecstore' && sleep 1 && xclip -o
	my $pid = fork();
	if (not defined $pid) {
		$pw = '';
		die "Fork failed: $!\n";
	} elsif ($pid == 0) {
		POSIX::setsid();

		open(FH, "|-", $incmd) or
		    die "Could not open command '$incmd': $!\n";
		print FH $pw;
		close FH;
		if ($? != 0) {
			system $delcmd;
			exit 1;
		}

		if ($sleep < 1) {
			exit 0;
		}

		$pw = sha256 $pw;
		$pid = fork();
		if (not defined $pid) {
			system $delcmd;
			die "Fork failed: $!\n";
		} elsif ($pid == 0) {
			open(STDOUT, '>/dev/null');
			open(STDERR, '>/dev/null');
			POSIX::setsid();
			sleep $sleep;
			system($delcmd) if
			    (sha256(`$outcmd`) eq $pw);
		}
	} else {
		$pw = '';
		waitpid $pid, 0;
		exit $?;
	}
}

getopts('d:') or usage();

scalar(@ARGV) >= 1 or usage();
my $cmd = $ARGV[0];
shift @ARGV;

my $secstore_dir = $opt_d // $ENV{SECSTORE_DIR};
unless (defined $secstore_dir) {
	if (defined $ENV{XDG_DATA_HOME}) {
		$secstore_dir = $ENV{XDG_DATA_HOME} . "/secstore";
	} elsif (defined $ENV{HOME}) {
		$secstore_dir = $ENV{HOME} . "/.secstore";
	} else {
		die "couldn't determine the secstore directory\n";
	}
}

make_path $secstore_dir, {mode => 0700};
chdir $secstore_dir or die "couldn't change directory to $secstore_dir: $!\n";

for ($cmd) {
if (/^add$/) {
	secstore_add(getflags "SECSTORE_ADD");
} elsif (/^(cp|copy)$/)	{
	secstore_copy(getflags "SECSTORE_COPY");
} elsif (/^(ls|list)$/) {
	secstore_list(getflags "SECSTORE_LIST");
} elsif (/^(mv|move)$/) {
	secstore_move(getflags "SECSTORE_MOVE");
} elsif (/^print$/) {
	secstore_print(getflags "SECSTORE_PRINT");
} elsif (/^(rm|remove)$/) {
	secstore_remove(getflags "SECSTORE_REMOVE");
} else {
	die "unknown command: " . $cmd . "\n"
}
}
