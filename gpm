#!/usr/bin/perl

use strict;
use warnings;

use IPC::Open2;
use Getopt::Std;
use File::Basename;
use File::Path 'make_path';

our ($opt_g, $opt_d, $opt_r);
my $gpg;

# usage: print usage information to stderr and exit with error.
sub usage {
	my $cmd = basename $0;
	die
"usage: $cmd [-g command] [-d dir] add [-m] name\n" .
"       $cmd [-d dir] rm name ...\n" .
"       $cmd [-g command] [-d dir] show name\n" .
"       $cmd [-d dir] mv from to\n" .
"       $cmd [-d dir] ls\n";
}

# getrecipient: return string to be used with gpg's -r option.
#
# Past versions of gpm (written in shell) required explicit recipient, set by
# option -r, or the GPM_RECIPIENT environment variable. This is completely
# unnecessary now, due to GPM_GPG and -g, but legacy syntax is still maintained.
sub getrecipient {
	my $r = $opt_r;
	defined $r or $r = $ENV{GPM_RECIPIENT};
	return $r;
}

# ckpath $path
#
# Return 1 if $path doesn't start with /, or contain .. files, and 0 otherwise.
sub ckpath {
	my ($p) = @_;
	return $p !~ m,^/, && $p ne ".." && $p !~ m,^\.\./, && $p !~ m,/\.\./,
	    && $p !~ m,/\.\.$,;
}

# cklegacy $f
#
# Returns the correct path for $f (with or without the .gpg suffix), or dies
# if no such file exists.
sub cklegacy {
	my ($f) = @_;
	if (!-f $f) {
		my $f2 = $f . ".gpg";
		-f $f2 or die "neither $f, nor $f2 exist as regular files\n";
		return $f2;
	}
	return $f;
}

# prunetree $d: remove empty directories, starting from $d, and going up.
sub prunetree {
	for (my ($d) = @_; $d ne "."; $d = dirname $d) {
		rmdir $d or last;
	}
}

# add
#
# Encrypt the secret from stdin, and store the ciphertext in file specified
# on the command line.
sub add {
	our $opt_m;
	my $r = getrecipient;
	my ($cmd, $sec);

	$cmd .= "$gpg -e";
	$cmd .= " -r $r" if defined $r;

	getopts('m') or usage;
	$#ARGV >= 0 or usage;

	my $outfile = $ARGV[0];
	ckpath $outfile or die "bad path: $outfile\n";

	-e $outfile and die "$outfile already exists\n";

	if (-t STDIN && !$opt_m) {
		system "stty -echo";

		print "Secret:";
		$sec = <STDIN>;
		print "\n";
		print "Repeat:";
		my $sec2 = <STDIN>;
		print "\n";
		die "Sorry\n" if $sec ne $sec2;

		system "stty echo";
	} else { while (<STDIN>) { $sec .= $_; } }

	my $pid = open2(my $reader, my $writer, $cmd);
	print $writer $sec;
	close($writer);
	my $out;
	while (<$reader>) { $out .= $_; }
	waitpid $pid, 0;
	$? == 0 or exit 1;

	my $d = dirname $outfile;
	make_path($d, {mode => 0700});
	umask 0377;
	unless (open FH, ">$outfile") {
		prunetree($d);
		die "couldn't open $outfile for writing: $!\n";
	}
	unless (print FH $out) {
		prunetree($d);
		die "couldn't write to $outfile: $!\n";
	}
}

# ls
#
# Produce a listing of files in the gpm directory, using the GPM_LSCMD
# environment variable if defined.
sub ls {
	my $cmd = $ENV{GPM_LSCMD};
	unless (defined $cmd) {
		opendir my $dh, "." or die "couldn't open directory .: $!\n";
		while (readdir $dh) {
			if ($_ ne "." && $_ ne ".." && -d $_) {
				$cmd = "find . -type f | sed 's,^\./,,'";
				last;
			}
		}
		$cmd = "ls" unless defined $cmd;
	}
	system($cmd);
	$? == 0 or exit 1;
}

# mv: safely rename $ARGV[0] to $ARGV[1].
sub mv {
	$#ARGV >= 1 || usage;
	my ($from, $to) = @ARGV;
	ckpath $from or die "bad path $from\n";
	ckpath $to or die "bad path $to\n";
	-e $to and die "$to already existst\n";
	$from = cklegacy $from;

	make_path(dirname $to, {mode => 0700});
	rename $from, $to;
	prunetree(dirname $from);
}

# rm: unlink arguments, asking each time.
sub rm {
	$#ARGV >= 0 || usage;
	for (@ARGV) {
		my $f = $_;
		unless (ckpath $f) {
			print STDERR "bad path $f\n";
			next;
		}
		$f = cklegacy $f;
		print "Really remove $f? ";
		<STDIN> =~ m/^[Yy]/ and unlink $f;
		prunetree(dirname $f);
	}
}

# show: decrypt file, and print plaintext to stdout.
sub show {
	$#ARGV >= 0 or usage;
	my $file = $ARGV[0];
	ckpath $file or die "bad path $file\n";
	$file = cklegacy $file;

	system("$gpg -d $file");
	$? == 0 or exit 1;
}

getopts('g:d:r') or usage;

$#ARGV >= 0 or usage;
my $cmd = $ARGV[0];
shift @ARGV;

$gpg = $opt_g;
$gpg = $ENV{GPM_GPG} unless defined $gpg;
$gpg = "gpg" unless defined $gpg;

my $gpmd = $opt_d;
defined $gpmd or $gpmd = $ENV{GPM_DIR};
unless (defined $gpmd) {
	if (defined $ENV{XDG_DATA_HOME}) {
		$gpmd = $ENV{XDG_DATA_HOME} . "/gpm";
	} elsif (defined $ENV{HOME}) {
		$gpmd = $ENV{HOME} . "/.gpm";
	} else {
		die "couldn't determine the gpm directory\n";
	}
}

make_path($gpmd, {mode => 0700});
chdir $gpmd or die "couldn't change directory to $gpmd: $!\n";

for ($cmd) {
if (/^a/) { add; last; }
if (/^l/) { ls; last; }
if (/^m/) { mv; last; }
if (/^r/) { rm; last; }
if (/^s/) { show; last; }
	usage;
}
